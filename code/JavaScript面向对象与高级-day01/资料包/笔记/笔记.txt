1. 面向对象的概念
    -> 传统面向过程编程
        问题
            1> 首先添加一个 input 标签
            2> 添加事件 onkeydown 事件
                在事件中需要获得用户的输入 获得事件对象
                如果不符合要求需要取消事件的默认行为  return false/ e.preventDefault( false )
        思考方式有一个特点
            所有的事情的都是按照前后顺序, 按照一定的步骤, 一步一步完成. 绝对不允许打乱的方式.
        面向过程的方式
            面向 -> 脸朝向 -> 关注, 注视, 使用
            过程 -> 细节, 步骤
            采用注意细节与步骤的开发方式
        
        生活中的面向过程
            1> 炒菜
            2> 开公司( 一个人 )
            
    -> 面向对象编程的概念
        字面: 
            面向 -> 关注, 使用, 注视
            对象 -> 泛化的概念. 它所表示的含义就是 你说关注和使用的目标
                    讨论的是生活, 对象就可以是一个人. 男女朋友
                    讨论的古生物学, 对象就可以是一个研究目标. 化石, 木乃伊等
                    讨论的是 DOM 开发, 对象就是 DOM 对象. 就是 HTML 元素( 对象 )
                    讨论的数学, 例如讨论的是 有限维的巴拿赫空间上的有限连续函数的积分

                    对象可以是具体的可以显示出来的, 可以摸得到的看得到的 物品或 看不到的抽象的思想等.
                    侧重点就是你所关注的东西.
        面向对象编程
            使用对象来编程.
            要完成某件事情, 先看看有没有对象可以完成, 如果有直接让对象来完成. 否则在自己实现.

            例如: 获得 页面中 id 为 dv 的 元素下的所有带有 itcast 属性, 而且包含子元素的所有的  p 标签
                

        案例:
            1> 炒菜
            2> 开公司( 500 人 )
                面向对象是将执行者变成一个管理者
            3> input 输入


    -> 面向对象与面向过程的关系
        案例: 
            1> 吃老家菜. 还是需要自己一步一步的去完成
            2> 吃老家菜. 带一个徒弟, 一次麻烦, 终身受益
            3> 去超市( 零食, 生鲜, 衣服, 洗漱, ... ). 在超市的内部依旧是面向对象的. 
            4> 在超市买 鱼 -> 渔农. 对于渔农来说就是面向过程.
        
        在开发的时候, 一般都是在考虑使用对象去完成任务
            1> 如果对象存在, 则直接使用对象来完成
            2> 如果对象不存在, 则自己实现完成. 这个就是 面向过程的.
            3> 如果对象不存在, 我使用 面向对象的 方式进行开发. 那么第一次是面向过程的. 而第二次或第 n 次就是面向对象.
            4> 面向过程才是具体的实现, 面向对象只是对面向过程的一个封装.




2. 面向对象的实现
    -> 什么是对象
        在代码中需要完成某些事情, 就需要对象来完成
        这个对象一定需要包含行为( 函数 ), 同时需要包含一些变量存储数据特征.

        案例:
            1> 计算 1 到 100 和
                - 找到对象              var cal = 可以计算的对象;   // calculate
                - 告诉这个对象计算什么   var res = cal.计算累加的和( 1, 100 )
                - 得到结果打印结果

            2> 在页面中需要一个轮播图
                - 找对象                 var scollView = 轮播图的对象;
                - 告诉它需要显示什么图片  scollView.imgs = [ img1, img2, img3, ... ]
                - 显示的宽高是多少        scollView.width = 200; scollView.height = 100;
                - 再告诉轮播图多久滚动一次 scollView.interval = 2;
                - 告诉它开始执行          scolleView.run()
        
        对象的行为常常称为 方法( method )
        对象存储数据的变量 称为 对象的属性 ( property )

        在 JavaScript 中 键值对 就是 对象. 如果键值存储的是数据那么这个就是属性, 如果键值存储的是函数那么就是方法.

    -> 创建对象
        -> 传统编程语言的方式( 如果将来会推 TSC 则需要详细说明 )
            代表语言: Java    
            对象是需要包含方法与属性的. 因此 以 Java 为代表的编程语言采用模板的方法来构造对象
                引入一个 叫 类( class )的 东西, 然后利用类来定义一个模板
                然后根据模板来创建对象. 这个模板决定了该对象具有什么属性以及什么方法 
            
            class 类名 {
                成员
            }
            // 定义好类以后就好比有了一个模板
            // 利用这个模板就可以创建对象
            var obj = new 类名()



        -> JavaScript 的方式( 很多方式 )
            -> 字面量
                -> 什么是字面量( literal ). 简单的说 就是 写出来就有数据值 就有类型的 量. 
                    123
                    "123". '123'
                    []
                    [ 123 ]
                -> 在 js 中使用 花括号表示 一个 对象. 对象的成员 采用 键值对的 语法放在花括号中. 如果有多个成员采用逗号分隔.
                    var o1 = {};            // 空对象, 不是 空
                    var o2 = { name: 'jim' };
                    var o3 = { name: 'jim', age: 19, gender: '男' };
                    var o4 = { name: 'jim', age: 19, gender: '男', sayHello: function () { console.log( '你好' ) } };
                -> 一般在书写对象的时候会采用换行与缩进的办法使得代码利于阅读
                    var o4 = { 
                        name: 'jim', 
                        age: 19, 
                        gender: '男', 
                        sayHello: function () { 
                          console.log( '你好' ) 
                        } 
                    };
                -> 结合对象的动态特性来创建对象
                    所谓的 对象的 动态特性 就是指 对象原本没有成员, 我们可以人为的为其赋值一个属性或方法, 那么这个对象就有这个成员了.
                    var o5 = {};

                    o5.name = 'jack';  // 如果该对象之前没有 name 属性, 那么该代码就会给对象增加该属性
                    o5.age = 20;
                    o5.gender = '女';
                    o5.sayHello = function () { }; 

                    这个写法有一个缺点, 就是必须是硬编码. 如果说可以允许在代码执行的时候 动态的给对象增加成员. 那才是真正的动态.
                    换句话说, 希望有一个变量, 存储属性的名字, 然后有一个变量存储对应的属性的值, 那么利用这个两个变量动态给对象增加属性

                    关联数组的用法
                    var o6 = {};

                    o6[ 'name' ] = 'tom';   // 等价于 o6.name = 'tom'


                    o6[ key ]  = value


            -> 工厂函数
                -> 什么是复用( 可重用 )
                    字面量是写出来的对象, 如果需要重复使用, 就需要重新再写. 因此没有办法复用.
                -> 可以考虑将创建对象的过程封装成函数
                    那么每次调用函数 就可以 创建一次 对象

                    function createPerson() {
                        var o = {}; // 创建对象了
                        
                        // ...

                        return o;
                    }

                    这样的函数有一个特点, 它就是为创建对象而存在的.
                    因此该方法( 函数 ) 常常被称为 工厂方法( 函数 )

                    也因此在命名的时候, 也使用 factory

                    function factory ( name, age, gender ) {
                        var o = {};
                        o.name = name;
                        o.age = age;
                        o.gender = gender;
                        return  o;
                    }


            -> 构造器
                -> 使用工厂还有一些缺点
                    1> 不方便与其他函数或方法区分开来
                    2> 利用工厂创建对象本质与字面量创建对象一样. 但是我们希望对象有类型. 
                        而使用字面量的方式创建的对象都是统一的 Object, 因此需要新的方法.
                -> 使用构造函数的方式来创建对象
                    1> 构造函数与普通函数类似. 唯一的不同是 约定 构造函数的名字采用 Pascal 命名规则.
                    2> 调用构造函数 采用语法 new 构造函数名()
                    3> 调用构造函数以后就是返回新创建的对象. 不需要写 return.
                    4> 在构造函数的内部使用 this 来表示刚创建的对象. 如果需要给对象提供成员使用 语法  this.XXX = XXX;

                function Person( name, age, gender ) {
                    this.name = name;
                    this.age = age;
                    this.gender = gender;

                    this.sayHello = function () {
                        console.log( 'xixixi哈哈哈' );
                    };
                }

                var p = new Person( 'jim', 19, '女' );


    -> 使用对象
        -> 只允许输入数字的文本框的案例
            如果考虑使用面向对象的方式去完成这个案例, 那么应该考虑有一个对象. 这个对象就是文本框
            同时也应该具备输入检查的功能. 如果输入了数字可以显示, 否则忽略.

            因此代码结构就变成了
                1> 添加 script 标签
                2> 创建对象  var  numInput = new NumInput();
                3> 将对象加到界面( 页面里面 )中
        -> 回顾一下 jquery 中 css 方法为 DOM 添加样式
            $( '#dv1' ).css( 'border', '1px solid red' );
            如果有多个样式属性需要加到 DOM 中, 可以利用对象给元素增加样式





3. 面向对象的基本特征
    -> 抽象性
        所谓的抽象性就是说只有在具体的环境中对象才可以表示具体的事物. 而在程序设计中实际只考虑对象的目标数据.
        { name, age, gender }
        { age, gender, 毛发, 天气 }

        局部性

    -> 封装性
        所谓封装性就是将具体的操作步骤打包起来, 那么不需要知道内部是如何处理的, 内部是多么的复杂, 只需要知道怎样用即可.


    -> 继承性
        继承在 OOP 中表示的就是 扩展. 原来已经有一个对象了. 在其基础上又增加一些东西得到一个新的对象. 此时这个
        新对象就是继承自原来的那个对象.

    -> 多态性( 了解 )
        多态就是多种状态. 也就是说一个变量调用某一个方法. 得到的是不同的结果.
            var o;
            o = 123;
            console.log( o.toString() );

            o = [ 1,2,3 ]
            console.log( o.toString() );

            o = function () {}
            console.log( o.toString() );


4. Error 对象
    -> 异常的概念
        原意: 异常就是在代码的运行过程中得到一个与预期结果不相同的答案, 这个就称为出现了异常.
        简单的解释, 就是在运行的时候出现了错误

    -> 如何处理异常
        语法:
            try { // 尝试
                可能出现异常的代码                 
            } catch ( e ) {   // exception
                如果出现了异常就执行
            }
    
    -> 异常对象的传递
        如果代码中出现了异常, 那么异常代码的后面的内容就不再执行了
        例如:
            function foo1 () {
                foo2()
            }
        此时: foo2 就被称为被调用函数
            foo1 就是调用函数
        
        凡是代码中出现了异常, 那么如果没有 try-catch 处理异常, 那么异常就会向该函数的调用函数进行传递
        如果调用函数处理了 try-catch, 那么就停下来. 如果调用函数没有处理, 那么就会传递放到调用函数的调用函数
        直到最顶层, 出现错误. 后面的代码不再执行.
        

    -> 异常对象
        在出现异常的时候, 异常出现的位置以及异常的类型, 内容等数据都会被封装起来. 
        以一个对象的形式被传递给 catch 后面的 e 中

        用户可以使用 语法
            throw 异常对象
        
        异常对象 new Error( 错误的消息 )

        如果我定义一个函数, 需要函数提供指定类型的参数, 如果传入的参数不正确, 一般会抛出一个异常.




5. DOM 对象
    -> DOM 的基本操作
        -> 什么是 DOM
            文档对象模型就是将每一个 HTML 标签, 当做一个 节点 对象来看待, 那么所有的标签就可以看成一个 节点树
            <html><head><title>123</title></head><body>123</body></html>
            将页面中的 123 换成 文本 456
        -> 基本操作
            增
            删
            改
            查
    -> DOM 树( 重点 )
        案例:
            <body>
                你好, 今天<i>天气很好</i>.
            <body>   
        注意: 在 html 中所有的内容都是节点对象 因此这里的文本标签全部都是对象
            因此 "你好, 今天" 是一个对象
            i 标签也是一个对象
            "添加很好" 也是一个对象

            body
                你好, 今天
                i
                    天气很好



6. 引用类型与值类型
    -> 数据类型
        1> 基本类型( 简单类型, 值类型 ): 数字 number, 字符串 string, 布尔 boolean
        2> 复杂类型( 复合类型, 引用类型 ): 对象( 数组, Object, 正则, ... ), 函数
        3> 空类型: undefined, null

    -> 存储模型( 重点中的 重点 )
        基本类型的变量存储数据本身, 比如 var num = 123; 在内存中开辟一段内存, 这个内存就是 num, 里面存储的 就是 数字 123

        引用类型就不一样了, 因为引用类型内的数据个数可以很大也可以很小. 因此不太容易说清楚要开辟多少内存存储数据.
        引用类型的变量只是存储对象的引用( 地址 ), 真正的数据存储在一个单独的内存中

        var p = { name: 'jim', age: 19, gender: '男', jiejie: { name: 'jiejie', age: 20, gender: '女' } }

        var p = { name: '张三', age: 19, gender: '男' }

    -> 作为参数传递的特征
        -> 在 赋值 过程中 值类型与引用类型的区别
            值类型: 值类型在赋值的时候是将数据取出来, 拷贝一份, 然后将拷贝的结果存储到 等号 左边的 变量中. 因此数据有两份.
                var num1 = 123;
                var num2;
                num2 = num1;
            引用类型: 引用类型在使用的时候都是使用变量来处理数据. 那么在赋值的时候, 就是将一个变量中的数据取出来, 拷贝一份, 
                     将拷贝的数据存储到另一个变量中. 由于引用类型的变量中存储的是引用而不是数据本身. 因此并没有将数据拷贝一份.
                     内存中依旧只有一份数据, 而是有两个变量同时执行着一个数据.

        -> 在 参数传递过程中值类型与引用类型的区别
            在函数调用时传递参数的时候 实际上是将 参数中的数据拷贝一份然后传递给函数内部的变量中
                function foo( num ) {
                }

                调用函数的时候
                var n = 123;
                foo( n )
                首先将 n 中的数据拷贝一份, 传入到 函数 foo 中 的 num 变量
            
            值类型: 在传入数据后, 是将值类型变量中存储的数据传入到函数中. 因此函数内的数据变化与函数外无关.
                    如果需要得到数据, 必须将数据返回才可以得到数据.

            引用类型: 在传入数据的时候, 是将变量的数据拷贝一份, 但是拷贝的是引用. 就是说在函数内部的这个变量
                     依旧指向最开始的对象. 也就是说在函数内外, 虽然两个变量不同, 但是指向的是同一个对象.


    -> 深拷贝与浅拷贝
        拷贝: 所谓的拷贝是需要将目标复制一份, 也就是说需要存在两个个体
            var num = 123;
            var n = num;
            // 因为在内存中有两个 123 因此这里是拷贝

            var o = { num: 123 }
            var obj = o;
            // 不是拷贝, 而是变量的引用发生了拷贝, 而数据只有一份
        案例:
            var p = {
                name: 'jim'
            }
            // 如果要实现拷贝的话 该怎么去做?
            1> 需要有一个对象    var p1 = {}
            2> 需要保证两个对象有相同的属性与方法
                p1.name = p.name
            3> 如果有很多属性?
                function clone( obj ) {
                    var o = {};
                    for ( var k in obj ) {
                        o[ k ] = obj[ k ];
                    }
                    return o;
                }
        案例:
            var p = {
                name: 'jim',
                car: {
                    name: '法拉利'
                }
            }

        所谓的浅拷贝就是只拷贝当前对象, 而不拷贝对象中引用的其他对象( 不拷贝所有的 对象 )
        所谓的深拷贝就是将所有涉及的对象全部拷贝一份, 在内存中两个对象是完全独立的
            function clone( obj ) {
                var o = {};
                for ( var k in obj ) {
                    o[ k ] = obj[ k ];  // 这个赋值是有问题的
                                        // 这里应该判断一下, 如果是基本类型直接赋值即可
                                        // 如果是引用类型应该再拷贝一次
                }
                return o;
            }
            // 改良
            function deepClone( obj ) {
                var o = {};
                for ( var k in obj ) {
                    if ( typeof obj[ k ]  == 'object' ) {
                        o[ k ] = deepClone( obj[ k ] );
                    } else {
                        o[ k ] = obj[ k ];
                    }

                    // o[ k ] = typeof obj[ k ] === 'object' ? deepClone( obj[ k ] ) : obj[ k ];
                }
                return o;
            }




























































