1. 原型的基本概念
    -> 为什么需要使用原型
        案例: 
            写一个构造函数, 要求创建一个 Person 对象, 包含 name, age, gender 和 说话 sayHello 的方法
        
            function Person( name, age, gender ) {
                this.name = name;
                this.age = age;
                this.gender = gender;
                this.sayHello = function () {
                    console.log( '你好, 我是 ' + this.name );
                };
            }

            var p = new Person( 'jim', 19, '男' );

            p.sayHello(); 
        
        思考: 构造函数的执行本质是什么, 这里对数据的优化有没有什么问题?
            构造函数的执行本质就是 对象的 动态特性
            1> 首先 new 是创建对象的运算符
            2> 然后该对象中什么东西都没有, 再调用构造函数, 在构造函数中 使用 this 表示当前对象.
            3> 利用对象的 动态特性 给 当前对象( this ) 增加成员.

        如果将方法写在 构造函数的内部, 那么函数每次执行的时候 方法的 代码就会被解释一次. 因此
        每一个对象都包含一个一模一样的不同的方法. 因此会浪费资源. 需要考虑将这个方法复用.

        让每一个由构造函数所创建出来的对象都共享一个方法就好了


            function sayHello () {
                console.log( '你好, 我是 ' + this.name );
            }

            function Person( name, age, gender, say ) {
                this.name = name;
                this.age = age;
                this.gender = gender;
                this.sayHello = say;
            }

        在 js 中凡是定义了一个函数, 就随之有一个对象存在. 函数的 prototype 属性指向该对象.
        该对象默认只包含一个属性 contructor, 再指向回 构造函数.
        凡是由构造函数创建的对象都默认的与这个神秘对象连接起来, 所谓的连接就是说凡是在这个
        神秘对象中提供的方法( 属性 ) 我们的对象都可以直接访问到.

        梳理一下:
        1> 凡是创建函数, 就会有一个对象存在( 神秘对象 ).
        2> 这个神秘对象默认含有 constructor 属性, 指向这个函数.
        3> 函数作为构造函数创建出来的对象可以直接使用这个神秘对象中的成员.


        结论: 神秘对象中的成员 被 构造函数所创建出来的对象所共享.

        prototype 就是原型的意思. 原型原本的含义就是原来的数据. 所以在函数背后的神秘对象就是函数的
        原型. 由于使用 prototype 这个属性来应用该对象, 因此我称作为 原型属性. 简称为原型.

        由于构造函数创建的对象可以直接连接到神秘对象中. 因此可以认为神秘对象提供的成员就是构造函数创建
        出来的对象的成员. 因此将神秘对象称为构造函数所创建出来的对象的 原型对象. 简称为原型.


        function Person() {}
        Person.prototype.sayHello = function () { ... };
        var p = new Person();
        p.sayHello();
        可以说 sayHello 就是 p 的方法


    -> 原型与构造函数和对象之间的关系


2. 原型继承
    -> 继承的概念( 复习 ) 
        什么是继承: 所谓的继承就是扩展, 在已有的对象上增加一些新的功能, 得到一个新的对象, 此时就是一个继承.
            生活中继承, 一般就是财产的继承. 此时的特点就是从别的个体中拿到一些东西. 
            血统的继承, 将别的个体中的一些东西组合起来构成一个个体.
            ... ...
            总结一下, 就是要从别人那里拿点东西过来.
        所谓的继承, 就是原本我没有, 但是我又需要, 那么有一个对象提供了对应的东西, 我将其拿过来, 让他成为我自己的东西. 那么我就有了.
            此时就称为 我继承自 这个对象.
        由于在 js 中没有继承语法结构( ES6 提供了继承的语法糖 )所以凡是涉及到原来一个对象没有, 但是从另一个对象中获得到了数据, 那么就是继承.

    -> 原型继承 
        对象 p 没有 sayHello 方法, 因为构造函数中什么都没有.
        但是 p 连接到 原型中了, 因此 对象 p 就可以调用 sayHello 方法.
        这个就是原型继承, 因为 p 没有, 但是 p 继承自原型对象, 所以 p 有了. 


    -> 代码实现( prototype 的使用方法 )
        -> 一般的使用
            将所有的方法都加到 原型中, 使用对象的动态特性增加成员.
            function Person ( name, age, gender ) {
                this.name = name;
                this.age = age;
                this.gender = gender;
            }
            Person.prototype.sayHello = function () {
                console.log( '你好, 我是 ' + this.name );
            };
            Person.prototype.run = function () {};



        -> 替换原型的方式使用
            function Person () {} // 就会自动的新增一个原始的原型对象, 在原始的原型对象中含有
                                  // constructor 属性.
            Person.prototype = {  // 直接替换原型对象, 来实现继承
                sayHello: function () { ... }
            }

            var p = new Person(); // 此时 p 就是自 新的 带有 sayHello 方法的对象



        -> Object.create 方法
            语法: 
                Object.create ( 对象 ) -> 对象
            该方法的含义返回一个原型对象为指定参数对象的对象
            



3. 相关概念扩展( js 与传统 oop 语言 ) 
    -> 实例, 对象, 构造器
        类 class, 一般将 js 中的构造函数称为 类. 所以一个对象的类型名就是构造函数的名字.
        构造函数, 构造器( constructor ), 构造方法 概念是一样的.
        利用构造函数 创建 对象的过 程称为 实例化, 因此将构造函数所创建出来的对象又称作为构造函数的实例.
        有些时候会将属性称为 字段

    -> 静态成员, 实例成员
        凡是定以后由实例对象所使用的成员就是实例成员
        凡是由构造方法所使用的成员就是静态成员

        访问规则
        1> 实例成员只允许在实例方法中直接被访问, 而在静态方法中不能访问
            function Person () {
                this.name = 'jim';
                this.sayHello = function () {
                    console.log( this.name );
                }
            }

            Person.sayGood = function () {
                // 在方法中 this 表示的是当前对象
                // this.name?
                // 即函数名
            }
        2> 无论是在实例方法中还是在静态方法中, 都可以访问静态成员( 只要保证可以访问到构造函数即可 )


        
4. 混入
    -> 混入的概念
        混入, 就是将一杯水倒入到一杯果汁中. 即将水混入到果汁中, 那么新的一杯液体就具有的水的特征和果汁的特征.
        所以就是将一个对象的成员加入到另一个对象中, 那么就可以完成对象功能的一个扩展( 继承 )

            var o1 = { 
                name: '张三'
            };
            var o2 = {
                sayHello: function () {
                    console.log( this.name );
                }
            }
            // 将 o1 中 name 混入到 o2 中
            o2.name = o1.name;

            o2.sayHello();
        
        如果对象的成员比较多的时候该如何处理呢?
            var o1 = { 
                name: '张三',
                age: 19,
                gender: '男',
                phone: '12345678909',
                qq: '123245678',
                address: '北京传智播客'
            };
            var o2 = {
                sayHello: function () {
                    console.log( this.name );
                }
            }
            // 将 o1  混入到 o2 中
            // o2.name = o1.name;
            // ...
            // ...
            for ( var k in o1 ) {

                o2[ k ] = o1[ k ];
            
            }


            o2.sayHello();



    -> mix
        使用 mix 可以将一个对象混入到另一个对象中
        function mix ( obj1, obj2 ) {
            for ( var k in obj2 ) {
                obj1[ k ] = obj2[ k ];
            }
        }

    -> extend
        这个单词的含义原意就是扩展, 所谓的混入就是将对象加入到一个对象中, 扩展该对象.
        function extend ( obj1, obj2 ) {
            for ( var k in obj2 ) {
                obj1[ k ] = obj2[ k ];
            }
        }

5. 混合式继承
    -> 已有的常用继承
        -> 原型式继承: 所谓原型式继承就是对象会自动的连接到其原型对象中, 而使用原型对象中所提供的成员
            一般在编写代码的时候都会将数据( 字段, 属性 )定义在构造器中, 而将方法定义在原型中.
            所以代码分成两部分.

            function Person( name ) {
                this.name = name;
            }
            Person.prototype.sayHello = function () {
                console.log( this.name );
            };

        -> 混入继承: 所谓的混入继承, 就是将一个对象中的成员遍历一遍, 依次加到另一个对象中, 那么另一个对象
            就具有了这个对象的功能. 从而实现继承.
            一般代码都会封装一个 mix 或 extend 函数( 方法 ). 使用该方法混入.

            function extend( obj1, obj2 ) {
                for ( var k in obj2 ) {
                    obj1[ k ] = obj2[ k ];
                }
            }
    -> 所谓混合式继承就是将 原型式继承与 混入继承组合到一起使用
        由于只介绍了这两种继承方式, 因此这么规定. 但是混合式继承的原意就是说将多种继承方式用到一起
        来完成继承.
        1> 基本的继承还是使用原型式. 也就是说在原型中提供方法和共享的属性. 在构造函数中提供独立的属性
        2> 在原型中提供成员的时候采用混入式继承



6. 属性搜索原则
    所谓的属性搜索原则, 就是说对象在访问某一个属性的时候采取的一种数据检索机制.
    一般我们的对象都是动态, 因此对象中有没有属性或方法是不确定. 在 js 中一个对象
    访问一个成员, 首先会在当前对象中检索是否包含该成员, 如果包含则使用. 如果不包含,
    那么就会自动的在其原型对象中查找是否有这个成员.

    这是读取数据, 如果是设置数据. 凡是设置数据都是在当前对象中进行操作.

7. 绘制 "原型构造实例三角形"




































































