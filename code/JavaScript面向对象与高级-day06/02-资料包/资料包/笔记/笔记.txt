1. 块级作用域与词法作用域
    -> 块级作用域
        什么是作用域: 所谓的作用域就是指起作用( 可使用 )的范围.

        一般在讨论作用域的时候是指某一个变量的可使用范围. 一般是指变量在定义后可以被使用, 
        而到某一个地方的时候就不能使用了. 就是指得这个范围.

        所谓的块, 是指一个代码的逻辑结构, 其中使用 {} 表示逻辑上的一句话. 但是里面可以包含多条语句.

        if ( 1 ) { 
            语句
            语句
            语句
        }

        这里的花括号就是语句块. 

        块级作用域是指从变量定义开始, 到变量所在的语句块结束, 在这样一个范围内可以被使用.

        在块级作用域中 子块 可以访问 父块, 反之不行.

        如果子块中含有与父块同名的变量( 声明 ), 那么会在定义该变量的时候隐藏父块中的变量.
        在子块中操作变量就是在操作子块中定义的 数据, 不会影响到 父块中的变量. 超出子块作用域后,
        父块中定义的变量就又可以使用了.




    -> 词法作用域
        词法作用域: 所谓的词法作用域, 就是指变量的访问规则按照词法定义的规则进行使用.
        这里的词法定义规则就是: 只有函数才可以限定作用域. 访问变量从当前作用域开始往上进行查找.
        这里的查找是指往作用域的上方进行查找, 而非代码的定义书写顺序查找.

        因此在词法作用域中存在作用域的上下关系( 作用域链 )





2. 变量访问规则
    -> 只有函数可以定义作用域
        1> 所有 script 标签可以看成一个独立的全局作用域. 记为 0 级作用域
        2> 从上往下, 凡是看到函数才会出现一个子级作用域. 其父作用域如果为 n 级作用域, 那么他就是 n+1 级作用域.
    -> 变量搜索原则
        凡是在访问变量的时候, 首先会在当前作用域中查找变量声明定义,
        如果在当前作用域中含有变量的声明或定义, 那么就会使用该变量,
        如果没有在当前作用域中找到变量的声明与定义, 那么就会去父级作用域中查找.
        ... ...
    -> 案例

3. javascript 的执行原理
    -> js 是解释型的语言
        就是将代码解释一句执行一句. 为了保证程序的高效运行. 在程序运行一开始的时候一个检查过程. 
        如果这个检查没有问题, 才会继续往下运行, 将代码从上往下, 从左至右的 一句一句的执行.

        这个检查过程就是预解析, 而执行过程就是解释执行过程

    -> 预解析
        1> 在预解析的时候需要检查基本的语法.
        2> 在当前作用域中检查所有的变量名声明. var 就是变量声明的标志.
            就是在此时在运行环境中就已经记录了有什么变量了. ( 变量名提升 )
        3> 在预解析的过程中会记录含有的函数声明. 如果不是函数声明, 那么是不会被记录的.

        函数的定义形式
            1> 声明式
                function foo ( args ) {
                    // 声明式函数
                }
            2> 函数表达式( 函数字面量 )
                var func = function foo () {
                    // 函数表达式
                };
            3> 使用 Function 构造函数

        函数声明必须在一个独立的代码结构中, 不允许将函数的声明嵌入到 语句中( if, while, for ... ).
        凡是嵌入到语句中, 函数声明会自定的将其转换成函数表达式. ( 嵌入花括号中是一个特例 )


        在花括号中的函数
            1> 在 大约 13 年之前, 谷歌浏览器在处理的时候, 凡是在花括号中的如下函数都是声明
                function 名字 () {
                }
               在火狐浏览器中不这么处理. 在火狐中好像是在花括号内的声明

               // 如果是声明应该在外面可以访问, 但是这个规则只有在花括号内起作用
               f();  // 是不会报错的
               {

                   function f() {}
               } 

               有一个经典的面试题
                if ( 1 ) {
                    function f() {
                        console.log( 'true' );
                    } 
                } else {
                    function f() {
                        console.log( 'false' );
                    }
                }
                // 给我们的感觉是 f 应该打印 'true', 但是, 13 年以前 谷歌 打印的是 false
                // 在 谷歌浏览器中 两个函数都是声明, 因此从上往下解析, 先解析得到是 true, 
                // 而后 又有一个 false, 覆盖了 true. 因此最后是 false.
                // 但是即使在 13 年 以前, 狐火中还是认为 if 起到了作用在 花括号的内部才是声明
                // 但是花括号的逻辑需要利用 if 来处理.

            2> 但是在今天 谷歌与火狐已经一样的处理这样的代码了

        在函数内部定义的函数, 也是在函数内部有一个声明的解析结构

        函数表达式
            var foo = function func () {
                // 函数表达式
            };

            函数名只允许在函数内部使用


            一般将函数写在 表达式中: 赋值, 圆括号, 取反, 等

    -> 解释执行
        


    
4. 代码分析
    


5. 绘制作用域链
    1> 将 0 级链中所有的变量, 函数等标识符放在一起. 绘制的时候就将其绘制成一条直线即可.
    2> 凡是函数可以创建新的作用域, 因此在函数下拉一条直线. 着条直线所在的函数是 n 级链, 那么这条链就是 n+1 级链
    3> 如果需要分析代码的执行结果, 将图画出来以后再来看代码的执行. 从代码的运行开始来在图中标注变量的值.















































































