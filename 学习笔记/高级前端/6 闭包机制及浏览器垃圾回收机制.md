### 闭包机制及浏览器垃圾回收机制

函数执行，产生一个私有的上下文，然后进栈

1 当函数执行完，一般情况下，当前形成的上下文都会被栈释放掉【优化栈内存】：上下文被释放，之前储存的私有变量等也会被释放

2 但是如果当前上下文中的某些东西【一般都是堆内存】，被当前上下文以外的事物所占用，则当前上下文不能出栈释放！ 之前声明的私有变量也都被储存起来了

市面上会把不被释放的上下文称为”闭包“   ***闭包是一种机制，函数执行产生的私有上下文，一方面可以保护里面的私有变量不被污染，另一方面如果不被释放，私有的变量及相关信息也都会保存起来，我们把这种”保护“ + "保护"的机制，称之为【闭包】！***

##### 题一：

```javascript
let x = 5;
function fn(x) {
    return function (y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7);  //14
fn(8)(9);  //18
f(10);  //18
console.log(x);  //5
```

图解：

![堆栈地址4](..\..\图片\js高级\堆栈地址4.png)

##### ++x&x++的区别

```javascript
//++x: 先累加1, 用累加后的结果再去运算
//x++: 先拿原始值取运算 运算结束后 自身累加1
//==》累加操作都是数学运算 和 x+=1(x=x+1)不完全一致
let i = 1;
console.log(5 + (++i));  //->7 
console.log(i);  // 2
//-------------------------
i = 1;
console.log(5 + (i++));  //=>6
console.log(i);  //=》 2
```

##### 题二(没懂) 垃圾回收了

```javascript
/*
 * EC(G)
 *   x=10
 *   fn=0x000「[[scope]]:EC(G)」 
 */
let x = 10;
function fn() {
    /*
     * EC(FN) 闭包
     *   y=20
     *   f=0x001「[[scope]]:EC(FN)」
     */
    let y=20;
    function f() {
        console.log(y);
    }
    window.f = f;
}
fn();
fn = null; //->把0x000堆释放掉 但是之前形成的上下文EC(FN)不受影响
f();
window.f=null;//->把0x001堆释放掉，此时EC(FN)中没有被外面占用的内容了，它也会被释放掉
```

